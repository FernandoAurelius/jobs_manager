# Generated by Django 5.2 on 2025-10-14 20:49

import logging
from collections import defaultdict

from django.db import migrations

logger = logging.getLogger(__name__)


def merge_duplicate_contacts(apps, schema_editor):
    """
    For each (client, name) combination with duplicates:
    - Keep the most recently updated contact
    - Prefer contacts with non-empty email addresses
    - Reassign all FK references (Job.contact) to the keeper
    - Delete the rest

    This prepares the database for the unique constraint on (client, name).
    """
    ClientContact = apps.get_model("client", "ClientContact")
    Job = apps.get_model("job", "Job")

    # Group all contacts by (client_id, name)
    contacts_by_client_name = defaultdict(list)

    for contact in ClientContact.objects.all().order_by("client_id", "name"):
        key = (contact.client_id, contact.name)
        contacts_by_client_name[key].append(contact)

    # Process groups with duplicates
    total_duplicates = 0
    total_deleted = 0
    total_jobs_reassigned = 0

    for (client_id, name), contacts in contacts_by_client_name.items():
        if len(contacts) <= 1:
            continue  # No duplicates, skip

        total_duplicates += 1

        # Sort to pick the best contact to keep:
        # 1. Prefer contacts with email (not null/empty)
        # 2. Then by most recent updated_at
        # 3. Then by most recent created_at
        contacts_sorted = sorted(
            contacts,
            key=lambda c: (
                bool(c.email and c.email.strip()),  # Has email (True = 1, False = 0)
                c.updated_at or c.created_at,  # Most recent update
                c.created_at,  # Most recent creation
            ),
            reverse=True,
        )

        # Keep the first (best) contact
        keeper = contacts_sorted[0]
        to_delete = contacts_sorted[1:]

        logger.info(
            f"Client {client_id}, name '{name}': "
            f"Keeping contact {keeper.id} (email={keeper.email}), "
            f"deleting {len(to_delete)} duplicate(s)"
        )

        # Reassign all FK references from duplicates to keeper
        for dup in to_delete:
            # Reassign jobs that reference this duplicate contact
            jobs_to_reassign = Job.objects.filter(contact_id=dup.id)
            jobs_count = jobs_to_reassign.count()
            if jobs_count > 0:
                logger.info(
                    f"  Reassigning {jobs_count} job(s) from duplicate "
                    f"contact {dup.id} to keeper {keeper.id}"
                )
                jobs_to_reassign.update(contact_id=keeper.id)
                total_jobs_reassigned += jobs_count

            logger.debug(f"  Deleting duplicate contact {dup.id} (email={dup.email})")
            dup.delete()
            total_deleted += 1

    if total_duplicates > 0:
        logger.info(
            f"Merged {total_duplicates} duplicate (client, name) combinations, "
            f"reassigned {total_jobs_reassigned} job(s), "
            f"deleted {total_deleted} duplicate contact records"
        )
    else:
        logger.info("No duplicate ClientContact records found - database is clean")


def reverse_migration(apps, schema_editor):
    """
    This migration cannot be reversed - we've deleted duplicate data.
    """
    logger.warning(
        "Cannot reverse merging of duplicate ClientContact records "
        "(deleted duplicates cannot be restored)"
    )


class Migration(migrations.Migration):
    dependencies = [
        ("client", "0007_delete_empty_name_contacts"),
    ]

    operations = [
        migrations.RunPython(merge_duplicate_contacts, reverse_migration),
    ]
