# Generated by Django 5.2 on 2025-10-11 03:57

import json
import logging
from datetime import datetime

from django.db import migrations

logger = logging.getLogger(__name__)


def populate_accounting_date(apps, schema_editor):
    """
    Populate accounting_date for all existing CostLine records.

    Logic:
    - Time entries: Use meta.date (the date the work was performed)
    - Materials from Stock: Use Stock.date (when material was received/created)
    - Materials from delivery: Use created_at.date() (when delivery was processed)
    - Adjustments: Use created_at.date() (when adjustment was made)
    """
    CostLine = apps.get_model("job", "CostLine")
    Stock = apps.get_model("purchasing", "Stock")

    total_count = CostLine.objects.count()
    logger.info(
        f"Starting to populate accounting_date for {total_count} CostLine records"
    )

    # Process time entries
    time_entries = CostLine.objects.filter(kind="time")
    time_count = 0
    time_errors = 0

    for line in time_entries:
        try:
            meta = line.meta if isinstance(line.meta, dict) else json.loads(line.meta)
            date_str = meta.get("date")
            if date_str:
                # Parse ISO date string
                if isinstance(date_str, str):
                    line.accounting_date = datetime.fromisoformat(date_str).date()
                else:
                    line.accounting_date = date_str
                line.save(update_fields=["accounting_date"])
                time_count += 1
            else:
                # Fallback to created_at if no meta.date
                line.accounting_date = line.created_at.date()
                line.save(update_fields=["accounting_date"])
                time_count += 1
                logger.warning(
                    f"Time entry {line.id} missing meta.date, using created_at"
                )
        except Exception as e:
            time_errors += 1
            logger.error(f"Error processing time entry {line.id}: {e}")
            # Set to created_at as fallback
            line.accounting_date = line.created_at.date()
            line.save(update_fields=["accounting_date"])

    logger.info(
        f"Processed {time_count} time entries ({time_errors} errors with fallback)"
    )

    # Process material entries
    material_entries = CostLine.objects.filter(kind="material")
    material_count = 0
    material_errors = 0

    for line in material_entries:
        try:
            ext_refs = (
                line.ext_refs
                if isinstance(line.ext_refs, dict)
                else json.loads(line.ext_refs)
            )

            # Try to get date from Stock if this material came from stock
            stock_id = ext_refs.get("stock_id")
            if stock_id:
                try:
                    stock = Stock.objects.get(id=stock_id)
                    # Stock.date is a datetime field
                    if isinstance(stock.date, datetime):
                        line.accounting_date = stock.date.date()
                    else:
                        line.accounting_date = stock.date
                    line.save(update_fields=["accounting_date"])
                    material_count += 1
                    continue
                except Stock.DoesNotExist:
                    logger.warning(
                        f"Stock {stock_id} not found for material {line.id}, using created_at"
                    )

            # If no stock or stock not found, use created_at
            line.accounting_date = line.created_at.date()
            line.save(update_fields=["accounting_date"])
            material_count += 1

        except Exception as e:
            material_errors += 1
            logger.error(f"Error processing material entry {line.id}: {e}")
            # Fallback to created_at
            line.accounting_date = line.created_at.date()
            line.save(update_fields=["accounting_date"])

    logger.info(
        f"Processed {material_count} material entries ({material_errors} errors with fallback)"
    )

    # Process adjustment entries - use bulk update for efficiency
    adjustment_count = CostLine.objects.filter(kind="adjust").count()

    # Can't use F("created_at__date") in migrations, so iterate
    for line in CostLine.objects.filter(kind="adjust"):
        line.accounting_date = line.created_at.date()
        line.save(update_fields=["accounting_date"])

    logger.info(f"Processed {adjustment_count} adjustment entries")

    # Verify all records have accounting_date
    null_count = CostLine.objects.filter(accounting_date__isnull=True).count()
    if null_count > 0:
        logger.error(
            f"WARNING: {null_count} CostLine records still have NULL accounting_date!"
        )
    else:
        logger.info("All CostLine records successfully populated with accounting_date")


def reverse_populate_accounting_date(apps, schema_editor):
    """Reverse migration: set all accounting_date to NULL"""
    CostLine = apps.get_model("job", "CostLine")
    CostLine.objects.update(accounting_date=None)
    logger.info("Reversed accounting_date population (set all to NULL)")


class Migration(migrations.Migration):
    dependencies = [
        ("job", "0047_add_accounting_date_nullable"),
        ("purchasing", "0014_remove_retail_rate_field"),  # Need Stock model
    ]

    operations = [
        migrations.RunPython(
            populate_accounting_date,
            reverse_code=reverse_populate_accounting_date,
        ),
    ]
