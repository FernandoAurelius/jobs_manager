# workflow/views/xero_base_creator.py
import logging
import json
from abc import ABC, abstractmethod
from typing import Any

from django.http import JsonResponse

from xero_python.accounting import AccountingApi
from xero_python.accounting.models import Contact

# Import models used in type hints or logic
from workflow.models import Job, Client
from workflow.api.xero.xero import api_client, get_tenant_id
from .xero_helpers import clean_payload, convert_to_pascal_case # Import helpers

logger = logging.getLogger("xero")

class XeroDocumentCreator(ABC):
    """
    Base class for creating Xero Documents (Invoices, Quotes, Purchase Orders).
    Implements common logic and provides abstract methods for customization.
    """

    job: Job | None # Job is optional now
    client: Client
    xero_api: AccountingApi
    xero_tenant_id: str

    def __init__(self, client, job=None):
        """
        Initializes the creator.

        Args:
            client (Client): The client or supplier associated with the document.
            job (Job, optional): The associated job. Defaults to None.
                                 Required for document types like Invoice/Quote.
                                 Not directly used for PurchaseOrder at this level.
        """
        if client is None:
             raise ValueError("Client cannot be None for XeroDocumentCreator")
        self.client = client
        self.job = job # Optional job association
        self.xero_api = AccountingApi(api_client)
        self.xero_tenant_id = get_tenant_id()

    @abstractmethod
    def get_xero_id(self) -> str | None:
        """
        Returns the Xero ID for the document if it exists locally.
        """
        pass

    @abstractmethod
    def state_valid_for_xero(self) -> bool:
        """
        Checks if the document is in a valid state to be sent to Xero.
        Returns True if valid, False otherwise.
        """
        pass

    @abstractmethod
    def get_line_items(self) -> list:
        """
        Returns a list of xero_python LineItem objects for the document.
        """
        pass

    @abstractmethod
    def get_xero_document(self, type: str) -> Any:
        """
        Returns a xero_python document model object (e.g., XeroInvoice, XeroQuote).
        """
        pass

    @abstractmethod
    def get_local_model(self) -> Any:
        """
        Returns the local Django model class for the document (e.g., Invoice, Quote).
        """
        pass

    @abstractmethod
    def get_xero_update_method(self) -> Any:
        """
        Returns the appropriate Xero API method for updating/creating the document
        (e.g., self.xero_api.update_or_create_invoices).
        """
        pass

    def validate_client(self):
        """
        Ensures the client exists and is synced with Xero.
        """
        if not self.client:
            # This check might be redundant now client is required in __init__
            raise ValueError("Client is missing")
        if not self.client.validate_for_xero():
            raise ValueError("Client data is not valid for Xero")
        if not self.client.xero_contact_id:
            raise ValueError(
                f"Client {self.client.name} does not have a valid Xero contact ID. Sync the client with Xero first."
            )

    def get_xero_contact(self) -> Contact:
        """
        Returns a Xero Contact object for the client.
        """
        return Contact(contact_id=self.client.xero_contact_id, name=self.client.name)

    def create_document(self):
        """
        Handles document creation and API communication with Xero.
        This method prepares the payload and calls the appropriate Xero API endpoint.
        Subclasses might override this for more specific response handling.
        """
        # Log the type of 'self' when this method is entered
        logger.info(f"Base create_document called with self type: {type(self)}")
        self.validate_client()

        if not self.state_valid_for_xero():
            raise ValueError(f"Document is not in a valid state for Xero submission.")

        # Use 'create' type for initial creation attempt
        xero_document = self.get_xero_document(type="create")

        try:
            # Convert to PascalCase to match XeroAPI required format and clean payload
            # Note: xero-python library expects snake_case for model init,
            # but the API call itself needs PascalCase. The library handles this,
            # but we apply conversion here before wrapping for the final API call structure.
            payload = convert_to_pascal_case(clean_payload(xero_document.to_dict()))
            logger.debug(f"Raw payload dictionary: {payload}")

            # Determine the correct payload structure for the API call
            # This depends on the specific endpoint (Invoices, Quotes, PurchaseOrders)
            # We need to import the specific creator types here eventually
            # Defer imports to avoid circular dependencies until files are created
            from .xero_invoice_creator import XeroInvoiceCreator
            from .xero_quote_creator import XeroQuoteCreator
            from .xero_po_creator import XeroPurchaseOrderCreator

            if isinstance(self, XeroInvoiceCreator):
                api_payload = {"Invoices": [payload]}
                api_method = self.xero_api.create_invoices
                kwargs = {'invoices': api_payload}
            elif isinstance(self, XeroQuoteCreator):
                api_payload = {"Quotes": [payload]}
                api_method = self.xero_api.create_quotes
                kwargs = {'quotes': api_payload}
            elif isinstance(self, XeroPurchaseOrderCreator):
                api_payload = {"PurchaseOrders": [payload]}
                api_method = self.xero_api.create_purchase_orders
                kwargs = {'purchase_orders': api_payload}
            else:
                raise ValueError("Unknown Xero document type for API payload structure.")

            logger.debug(f"Final API payload: {json.dumps(api_payload, indent=4)}")

        except Exception as e:
            logger.error(f"Error preparing payload for XeroDocument: {str(e)}", exc_info=True)
            raise # Re-raise after logging

        try:
            logger.info(f"Attempting to call Xero API method: {api_method.__name__}")
            response, http_status, http_headers = api_method(
                self.xero_tenant_id, **kwargs, _return_http_data_only=False
            )

            logger.debug(f"Xero API Response Content: {response}")
            logger.debug(f"Xero API HTTP Status: {http_status}")
            # logger.debug(f"HTTP Headers: {http_headers}")

        except Exception as e:
            # Log details before re-raising or handling in subclass
            logger.error(f"Error calling Xero API method {api_method.__name__}: {str(e)}")
            if hasattr(e, "body"):
                logger.error(f"Xero API Response body: {e.body}")
            raise # Re-raise for specific handling in view or subclass

        return response # Return the raw xero-python response object

    def delete_document(self):
        """
        Handles document deletion and API communication with Xero.
        Requires subclasses to implement get_xero_update_method appropriately
        (e.g., returning self.xero_api.update_or_create_invoices for setting status to DELETED).
        """
        self.validate_client()
        # Get the document representation needed for deletion (usually includes ID and status=DELETED)
        xero_document = self.get_xero_document(type="delete")

        try:
            payload = convert_to_pascal_case(clean_payload(xero_document.to_dict()))
            logger.debug(f"Serialized payload for delete: {json.dumps(payload, indent=4)}")

            # Determine the correct payload structure for the API call (similar to create)
            # Defer imports to avoid circular dependencies until files are created
            from .xero_invoice_creator import XeroInvoiceCreator
            from .xero_quote_creator import XeroQuoteCreator
            from .xero_po_creator import XeroPurchaseOrderCreator

            if isinstance(self, XeroInvoiceCreator):
                api_payload = {"Invoices": [payload]}
                # Deletion is often handled by POST/PUT with status=DELETED
                api_method = self.get_xero_update_method()
                kwargs = {'invoices': api_payload}
            elif isinstance(self, XeroQuoteCreator):
                api_payload = {"Quotes": [payload]}
                api_method = self.get_xero_update_method()
                kwargs = {'quotes': api_payload}
            elif isinstance(self, XeroPurchaseOrderCreator):
                api_payload = {"PurchaseOrders": [payload]}
                api_method = self.get_xero_update_method()
                kwargs = {'purchase_orders': api_payload}
            else:
                raise ValueError("Unknown Xero document type for delete payload structure.")

        except Exception as e:
            logger.error(f"Error preparing payload for Xero document deletion: {str(e)}", exc_info=True)
            raise

        try:
            logger.info(f"Attempting to call Xero API method for delete: {api_method.__name__}")
            response, http_status, http_headers = api_method(
                self.xero_tenant_id, **kwargs, _return_http_data_only=False
            )

            logger.debug(f"Xero API Delete Response Content: {response}")
            logger.debug(f"Xero API Delete HTTP Status: {http_status}")

        except Exception as e:
            logger.error(f"Error calling Xero API method {api_method.__name__} for delete: {str(e)}")
            if hasattr(e, "body"):
                logger.error(f"Xero API Delete Response body: {e.body}")
            raise

        return response
    

# workflow/views/xero_quote_creator.py
import logging
import json
from decimal import Decimal
from datetime import timedelta

from django.http import JsonResponse
from django.utils import timezone

# Import base class and helpers
from .xero_base_creator import XeroDocumentCreator
from .xero_helpers import format_date # Assuming format_date is needed

# Import models
from workflow.models import Quote, Job, Client # Add Job, Client if needed by methods
from workflow.enums import QuoteStatus
from xero_python.accounting.models import LineItem, Quote as XeroQuote
from xero_python.exceptions import AccountingBadRequestException # If specific exceptions handled

logger = logging.getLogger("xero")

class XeroQuoteCreator(XeroDocumentCreator):
    """
    Handles Quote creation in Xero.
    """
    def __init__(self, client, job):
        """
        Initializes the quote creator. Both client and job are required for quotes.
        Calls the base class __init__ ensuring consistent signature.
        """
        if not client or not job:
             raise ValueError("Client and Job are required for XeroQuoteCreator")
        # Call the base class __init__ with the client and the job
        super().__init__(client=client, job=job)

    def get_xero_id(self):
        # self.job is guaranteed to exist here due to the __init__ check
        return str(self.job.quote.xero_id) if hasattr(self.job, "quote") and self.job.quote else None

    def get_xero_update_method(self):
        # For quotes, update/create might be the same endpoint or specific ones
        # Assuming update_or_create_quotes exists and handles setting status to DELETED
        return self.xero_api.update_or_create_quotes

    def get_local_model(self):
        return Quote

    def state_valid_for_xero(self):
        """
        Checks if the job is in a valid state to be quoted in Xero.
        Returns True if valid, False otherwise.
        """
        # self.job is guaranteed to exist here due to the __init__ check
        return not self.job.quoted

    # --- Methods moved from the misplaced block ---

    def validate_job(self):
        """
        Ensures the job is valid for quote creation.
        (This seems redundant now with state_valid_for_xero, consider removing/merging)
        """
        if self.job.quoted:
            raise ValueError(f"Job {self.job.id} is already quoted.")

    def get_line_items(self):
        """
        Generate quote-specific LineItems.
        """
        # Ensure job and pricing exist
        if not self.job or not hasattr(self.job, 'latest_quote_pricing') or not self.job.latest_quote_pricing:
             raise ValueError(f"Job {self.job.id if self.job else 'Unknown'} is missing quote pricing information.")

        line_items = [
            LineItem(
                description=f"Quote for job: {self.job.job_number}{(" - " + self.job.description) if self.job.description else ''}",
                quantity=1,
                unit_amount=float(self.job.latest_quote_pricing.total_revenue) or 0.00,
                # Assuming account code 200 is correct for quotes
                account_code="200",
            )
        ]
        return line_items

    def get_xero_document(self, type: str) -> XeroQuote:
        """
        Creates a quote object for Xero creation or deletion.
        """
        # Ensure job exists before accessing attributes
        if not self.job:
            raise ValueError("Job is required to get Xero document for a quote.")

        match (type):
            case "create":
                # Use job.client which is guaranteed by __init__
                contact = self.get_xero_contact()
                line_items = self.get_line_items()
                base_data = {
                    "contact": contact,
                    "line_items": line_items,
                    "date": format_date(timezone.now()),
                    "expiry_date": format_date(timezone.now() + timedelta(days=30)),
                    "line_amount_types": "Exclusive", # Assuming Exclusive
                    "currency_code": "NZD", # Assuming NZD
                    "status": "DRAFT",
                }
                # Add reference only if job has an order_number
                if hasattr(self.job, 'order_number') and self.job.order_number:
                    base_data["reference"] = self.job.order_number

                return XeroQuote(**base_data)

            case "delete":
                xero_id = self.get_xero_id()
                if not xero_id:
                    raise ValueError("Cannot delete quote without a Xero ID.")
                # Deletion typically involves setting status to DELETED via an update call
                return XeroQuote(
                    quote_id=xero_id,
                    status="DELETED",
                    # Other fields might be required by Xero API for update/delete status change
                    # contact=self.get_xero_contact(), # Likely not needed for delete status change
                    # line_items=self.get_line_items(), # Likely not needed for delete status
                    # date=format_date(timezone.now()), # Likely not needed for delete status
                )
            case _:
                 raise ValueError(f"Unknown document type for Quote: {type}")


    def create_document(self):
        """Creates a quote, processes response, stores locally and returns the quote URL."""
        # Calls the base class create_document to handle API call
        response = super().create_document()

        if response and response.quotes:
            xero_quote_data = response.quotes[0]
            xero_quote_id = getattr(xero_quote_data, 'quote_id', None)
            if not xero_quote_id:
                 logger.error("Xero response missing quote_id.")
                 raise ValueError("Xero response missing quote_id.")

            quote_url = f"https://go.xero.com/app/quotes/edit/{xero_quote_id}"

            # Create local Quote record
            quote = Quote.objects.create(
                xero_id=xero_quote_id,
                job=self.job,
                client=self.client,
                date=timezone.now().date(),
                status=QuoteStatus.DRAFT, # Set local status
                total_excl_tax=Decimal(getattr(xero_quote_data, 'sub_total', 0)),
                total_incl_tax=Decimal(getattr(xero_quote_data, 'total', 0)),
                xero_last_modified=timezone.now(), # Use current time as approximation
                xero_last_synced=timezone.now(),
                online_url=quote_url,
                # Store raw response for debugging
                raw_json=json.dumps(xero_quote_data.to_dict(), default=str),
            )

            logger.info(f"Quote {quote.id} created successfully for job {self.job.id}")

            # Return success details for the view
            return JsonResponse(
                {
                    "success": True,
                    "xero_id": str(xero_quote_id),
                    "client": self.client.name,
                    "quote_url": quote_url,
                }
            )
        else:
            # Handle API failure or unexpected response
            error_msg = "No quotes found in the Xero response or failed to create quote."
            logger.error(error_msg)
            # Attempt to extract more details if possible
            if response and hasattr(response, 'elements') and response.elements:
                 first_element = response.elements[0]
                 if hasattr(first_element, 'validation_errors') and first_element.validation_errors:
                     error_msg = "; ".join([err.message for err in first_element.validation_errors])
                 elif hasattr(first_element, 'message'):
                      error_msg = first_element.message

            return JsonResponse(
                {"success": False, "error": error_msg},
                status=400, # Use 400 for API/validation errors
            )

    def delete_document(self):
        """Deletes a quote in Xero and locally."""
        # Calls the base class delete_document which handles the API call
        response = super().delete_document()

        if response and response.quotes:
             # Check if the response indicates successful deletion (e.g., status is DELETED)
             # Note: Xero API might just return the updated object with DELETED status
             xero_quote_data = response.quotes[0]
             if str(getattr(xero_quote_data, 'status', '')).upper() == 'DELETED':
                 # Delete local record only after confirming Xero deletion/update
                 if hasattr(self.job, 'quote') and self.job.quote:
                     local_quote_id = self.job.quote.id
                     self.job.quote.delete()
                     logger.info(f"Quote {local_quote_id} deleted successfully for job {self.job.id}")
                 else:
                      logger.warning(f"No local quote found for job {self.job.id} to delete.")
                 return JsonResponse({"success": True})
             else:
                  error_msg = "Xero response did not confirm quote deletion."
                  logger.error(f"{error_msg} Status: {getattr(xero_quote_data, 'status', 'Unknown')}")
                  return JsonResponse({"success": False, "error": error_msg}, status=400)
        else:
            error_msg = "No quotes found in the Xero response or failed to delete quote."
            logger.error(error_msg)
            return JsonResponse({"success": False, "error": error_msg}, status=400)